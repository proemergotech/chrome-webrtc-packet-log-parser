// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rtc_event_log.proto

/*
Package webrtc_rtclog is a generated protocol buffer package.

It is generated from these files:
	rtc_event_log.proto

It has these top-level messages:
	EventStream
	Event
	RtpPacket
	RtcpPacket
	AudioPlayoutEvent
	LossBasedBweUpdate
	DelayBasedBweUpdate
	VideoReceiveConfig
	DecoderConfig
	RtpHeaderExtension
	RtxConfig
	RtxMap
	VideoSendConfig
	EncoderConfig
	AudioReceiveConfig
	AudioSendConfig
	AudioNetworkAdaptation
	BweProbeCluster
	BweProbeResult
	AlrState
	IceCandidatePairConfig
	IceCandidatePairEvent
*/
package webrtc_rtclog

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MediaType int32

const (
	MediaType_ANY   MediaType = 0
	MediaType_AUDIO MediaType = 1
	MediaType_VIDEO MediaType = 2
	MediaType_DATA  MediaType = 3
)

var MediaType_name = map[int32]string{
	0: "ANY",
	1: "AUDIO",
	2: "VIDEO",
	3: "DATA",
}
var MediaType_value = map[string]int32{
	"ANY":   0,
	"AUDIO": 1,
	"VIDEO": 2,
	"DATA":  3,
}

func (x MediaType) Enum() *MediaType {
	p := new(MediaType)
	*p = x
	return p
}
func (x MediaType) String() string {
	return proto.EnumName(MediaType_name, int32(x))
}
func (x *MediaType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaType_value, data, "MediaType")
	if err != nil {
		return err
	}
	*x = MediaType(value)
	return nil
}
func (MediaType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// The different types of events that can occur, the UNKNOWN_EVENT entry
// is added in case future EventTypes are added, in that case old code will
// receive the new events as UNKNOWN_EVENT.
type Event_EventType int32

const (
	Event_UNKNOWN_EVENT                   Event_EventType = 0
	Event_LOG_START                       Event_EventType = 1
	Event_LOG_END                         Event_EventType = 2
	Event_RTP_EVENT                       Event_EventType = 3
	Event_RTCP_EVENT                      Event_EventType = 4
	Event_AUDIO_PLAYOUT_EVENT             Event_EventType = 5
	Event_LOSS_BASED_BWE_UPDATE           Event_EventType = 6
	Event_DELAY_BASED_BWE_UPDATE          Event_EventType = 7
	Event_VIDEO_RECEIVER_CONFIG_EVENT     Event_EventType = 8
	Event_VIDEO_SENDER_CONFIG_EVENT       Event_EventType = 9
	Event_AUDIO_RECEIVER_CONFIG_EVENT     Event_EventType = 10
	Event_AUDIO_SENDER_CONFIG_EVENT       Event_EventType = 11
	Event_AUDIO_NETWORK_ADAPTATION_EVENT  Event_EventType = 16
	Event_BWE_PROBE_CLUSTER_CREATED_EVENT Event_EventType = 17
	Event_BWE_PROBE_RESULT_EVENT          Event_EventType = 18
	Event_ALR_STATE_EVENT                 Event_EventType = 19
	Event_ICE_CANDIDATE_PAIR_CONFIG       Event_EventType = 20
	Event_ICE_CANDIDATE_PAIR_EVENT        Event_EventType = 21
)

var Event_EventType_name = map[int32]string{
	0:  "UNKNOWN_EVENT",
	1:  "LOG_START",
	2:  "LOG_END",
	3:  "RTP_EVENT",
	4:  "RTCP_EVENT",
	5:  "AUDIO_PLAYOUT_EVENT",
	6:  "LOSS_BASED_BWE_UPDATE",
	7:  "DELAY_BASED_BWE_UPDATE",
	8:  "VIDEO_RECEIVER_CONFIG_EVENT",
	9:  "VIDEO_SENDER_CONFIG_EVENT",
	10: "AUDIO_RECEIVER_CONFIG_EVENT",
	11: "AUDIO_SENDER_CONFIG_EVENT",
	16: "AUDIO_NETWORK_ADAPTATION_EVENT",
	17: "BWE_PROBE_CLUSTER_CREATED_EVENT",
	18: "BWE_PROBE_RESULT_EVENT",
	19: "ALR_STATE_EVENT",
	20: "ICE_CANDIDATE_PAIR_CONFIG",
	21: "ICE_CANDIDATE_PAIR_EVENT",
}
var Event_EventType_value = map[string]int32{
	"UNKNOWN_EVENT":                   0,
	"LOG_START":                       1,
	"LOG_END":                         2,
	"RTP_EVENT":                       3,
	"RTCP_EVENT":                      4,
	"AUDIO_PLAYOUT_EVENT":             5,
	"LOSS_BASED_BWE_UPDATE":           6,
	"DELAY_BASED_BWE_UPDATE":          7,
	"VIDEO_RECEIVER_CONFIG_EVENT":     8,
	"VIDEO_SENDER_CONFIG_EVENT":       9,
	"AUDIO_RECEIVER_CONFIG_EVENT":     10,
	"AUDIO_SENDER_CONFIG_EVENT":       11,
	"AUDIO_NETWORK_ADAPTATION_EVENT":  16,
	"BWE_PROBE_CLUSTER_CREATED_EVENT": 17,
	"BWE_PROBE_RESULT_EVENT":          18,
	"ALR_STATE_EVENT":                 19,
	"ICE_CANDIDATE_PAIR_CONFIG":       20,
	"ICE_CANDIDATE_PAIR_EVENT":        21,
}

func (x Event_EventType) Enum() *Event_EventType {
	p := new(Event_EventType)
	*p = x
	return p
}
func (x Event_EventType) String() string {
	return proto.EnumName(Event_EventType_name, int32(x))
}
func (x *Event_EventType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_EventType_value, data, "Event_EventType")
	if err != nil {
		return err
	}
	*x = Event_EventType(value)
	return nil
}
func (Event_EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type DelayBasedBweUpdate_DetectorState int32

const (
	DelayBasedBweUpdate_BWE_NORMAL     DelayBasedBweUpdate_DetectorState = 0
	DelayBasedBweUpdate_BWE_UNDERUSING DelayBasedBweUpdate_DetectorState = 1
	DelayBasedBweUpdate_BWE_OVERUSING  DelayBasedBweUpdate_DetectorState = 2
)

var DelayBasedBweUpdate_DetectorState_name = map[int32]string{
	0: "BWE_NORMAL",
	1: "BWE_UNDERUSING",
	2: "BWE_OVERUSING",
}
var DelayBasedBweUpdate_DetectorState_value = map[string]int32{
	"BWE_NORMAL":     0,
	"BWE_UNDERUSING": 1,
	"BWE_OVERUSING":  2,
}

func (x DelayBasedBweUpdate_DetectorState) Enum() *DelayBasedBweUpdate_DetectorState {
	p := new(DelayBasedBweUpdate_DetectorState)
	*p = x
	return p
}
func (x DelayBasedBweUpdate_DetectorState) String() string {
	return proto.EnumName(DelayBasedBweUpdate_DetectorState_name, int32(x))
}
func (x *DelayBasedBweUpdate_DetectorState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DelayBasedBweUpdate_DetectorState_value, data, "DelayBasedBweUpdate_DetectorState")
	if err != nil {
		return err
	}
	*x = DelayBasedBweUpdate_DetectorState(value)
	return nil
}
func (DelayBasedBweUpdate_DetectorState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

// Compound mode is described by RFC 4585 and reduced-size
// RTCP mode is described by RFC 5506.
type VideoReceiveConfig_RtcpMode int32

const (
	VideoReceiveConfig_RTCP_COMPOUND    VideoReceiveConfig_RtcpMode = 1
	VideoReceiveConfig_RTCP_REDUCEDSIZE VideoReceiveConfig_RtcpMode = 2
)

var VideoReceiveConfig_RtcpMode_name = map[int32]string{
	1: "RTCP_COMPOUND",
	2: "RTCP_REDUCEDSIZE",
}
var VideoReceiveConfig_RtcpMode_value = map[string]int32{
	"RTCP_COMPOUND":    1,
	"RTCP_REDUCEDSIZE": 2,
}

func (x VideoReceiveConfig_RtcpMode) Enum() *VideoReceiveConfig_RtcpMode {
	p := new(VideoReceiveConfig_RtcpMode)
	*p = x
	return p
}
func (x VideoReceiveConfig_RtcpMode) String() string {
	return proto.EnumName(VideoReceiveConfig_RtcpMode_name, int32(x))
}
func (x *VideoReceiveConfig_RtcpMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VideoReceiveConfig_RtcpMode_value, data, "VideoReceiveConfig_RtcpMode")
	if err != nil {
		return err
	}
	*x = VideoReceiveConfig_RtcpMode(value)
	return nil
}
func (VideoReceiveConfig_RtcpMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

type BweProbeResult_ResultType int32

const (
	BweProbeResult_SUCCESS                       BweProbeResult_ResultType = 0
	BweProbeResult_INVALID_SEND_RECEIVE_INTERVAL BweProbeResult_ResultType = 1
	BweProbeResult_INVALID_SEND_RECEIVE_RATIO    BweProbeResult_ResultType = 2
	BweProbeResult_TIMEOUT                       BweProbeResult_ResultType = 3
)

var BweProbeResult_ResultType_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_SEND_RECEIVE_INTERVAL",
	2: "INVALID_SEND_RECEIVE_RATIO",
	3: "TIMEOUT",
}
var BweProbeResult_ResultType_value = map[string]int32{
	"SUCCESS":                       0,
	"INVALID_SEND_RECEIVE_INTERVAL": 1,
	"INVALID_SEND_RECEIVE_RATIO":    2,
	"TIMEOUT":                       3,
}

func (x BweProbeResult_ResultType) Enum() *BweProbeResult_ResultType {
	p := new(BweProbeResult_ResultType)
	*p = x
	return p
}
func (x BweProbeResult_ResultType) String() string {
	return proto.EnumName(BweProbeResult_ResultType_name, int32(x))
}
func (x *BweProbeResult_ResultType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BweProbeResult_ResultType_value, data, "BweProbeResult_ResultType")
	if err != nil {
		return err
	}
	*x = BweProbeResult_ResultType(value)
	return nil
}
func (BweProbeResult_ResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{18, 0}
}

type IceCandidatePairConfig_IceCandidatePairConfigType int32

const (
	IceCandidatePairConfig_ADDED     IceCandidatePairConfig_IceCandidatePairConfigType = 0
	IceCandidatePairConfig_UPDATED   IceCandidatePairConfig_IceCandidatePairConfigType = 1
	IceCandidatePairConfig_DESTROYED IceCandidatePairConfig_IceCandidatePairConfigType = 2
	IceCandidatePairConfig_SELECTED  IceCandidatePairConfig_IceCandidatePairConfigType = 3
)

var IceCandidatePairConfig_IceCandidatePairConfigType_name = map[int32]string{
	0: "ADDED",
	1: "UPDATED",
	2: "DESTROYED",
	3: "SELECTED",
}
var IceCandidatePairConfig_IceCandidatePairConfigType_value = map[string]int32{
	"ADDED":     0,
	"UPDATED":   1,
	"DESTROYED": 2,
	"SELECTED":  3,
}

func (x IceCandidatePairConfig_IceCandidatePairConfigType) Enum() *IceCandidatePairConfig_IceCandidatePairConfigType {
	p := new(IceCandidatePairConfig_IceCandidatePairConfigType)
	*p = x
	return p
}
func (x IceCandidatePairConfig_IceCandidatePairConfigType) String() string {
	return proto.EnumName(IceCandidatePairConfig_IceCandidatePairConfigType_name, int32(x))
}
func (x *IceCandidatePairConfig_IceCandidatePairConfigType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IceCandidatePairConfig_IceCandidatePairConfigType_value, data, "IceCandidatePairConfig_IceCandidatePairConfigType")
	if err != nil {
		return err
	}
	*x = IceCandidatePairConfig_IceCandidatePairConfigType(value)
	return nil
}
func (IceCandidatePairConfig_IceCandidatePairConfigType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 0}
}

type IceCandidatePairConfig_IceCandidateType int32

const (
	IceCandidatePairConfig_LOCAL                  IceCandidatePairConfig_IceCandidateType = 0
	IceCandidatePairConfig_STUN                   IceCandidatePairConfig_IceCandidateType = 1
	IceCandidatePairConfig_PRFLX                  IceCandidatePairConfig_IceCandidateType = 2
	IceCandidatePairConfig_RELAY                  IceCandidatePairConfig_IceCandidateType = 3
	IceCandidatePairConfig_UNKNOWN_CANDIDATE_TYPE IceCandidatePairConfig_IceCandidateType = 4
)

var IceCandidatePairConfig_IceCandidateType_name = map[int32]string{
	0: "LOCAL",
	1: "STUN",
	2: "PRFLX",
	3: "RELAY",
	4: "UNKNOWN_CANDIDATE_TYPE",
}
var IceCandidatePairConfig_IceCandidateType_value = map[string]int32{
	"LOCAL":                  0,
	"STUN":                   1,
	"PRFLX":                  2,
	"RELAY":                  3,
	"UNKNOWN_CANDIDATE_TYPE": 4,
}

func (x IceCandidatePairConfig_IceCandidateType) Enum() *IceCandidatePairConfig_IceCandidateType {
	p := new(IceCandidatePairConfig_IceCandidateType)
	*p = x
	return p
}
func (x IceCandidatePairConfig_IceCandidateType) String() string {
	return proto.EnumName(IceCandidatePairConfig_IceCandidateType_name, int32(x))
}
func (x *IceCandidatePairConfig_IceCandidateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IceCandidatePairConfig_IceCandidateType_value, data, "IceCandidatePairConfig_IceCandidateType")
	if err != nil {
		return err
	}
	*x = IceCandidatePairConfig_IceCandidateType(value)
	return nil
}
func (IceCandidatePairConfig_IceCandidateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 1}
}

type IceCandidatePairConfig_Protocol int32

const (
	IceCandidatePairConfig_UDP              IceCandidatePairConfig_Protocol = 0
	IceCandidatePairConfig_TCP              IceCandidatePairConfig_Protocol = 1
	IceCandidatePairConfig_SSLTCP           IceCandidatePairConfig_Protocol = 2
	IceCandidatePairConfig_TLS              IceCandidatePairConfig_Protocol = 3
	IceCandidatePairConfig_UNKNOWN_PROTOCOL IceCandidatePairConfig_Protocol = 4
)

var IceCandidatePairConfig_Protocol_name = map[int32]string{
	0: "UDP",
	1: "TCP",
	2: "SSLTCP",
	3: "TLS",
	4: "UNKNOWN_PROTOCOL",
}
var IceCandidatePairConfig_Protocol_value = map[string]int32{
	"UDP":              0,
	"TCP":              1,
	"SSLTCP":           2,
	"TLS":              3,
	"UNKNOWN_PROTOCOL": 4,
}

func (x IceCandidatePairConfig_Protocol) Enum() *IceCandidatePairConfig_Protocol {
	p := new(IceCandidatePairConfig_Protocol)
	*p = x
	return p
}
func (x IceCandidatePairConfig_Protocol) String() string {
	return proto.EnumName(IceCandidatePairConfig_Protocol_name, int32(x))
}
func (x *IceCandidatePairConfig_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IceCandidatePairConfig_Protocol_value, data, "IceCandidatePairConfig_Protocol")
	if err != nil {
		return err
	}
	*x = IceCandidatePairConfig_Protocol(value)
	return nil
}
func (IceCandidatePairConfig_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 2}
}

type IceCandidatePairConfig_AddressFamily int32

const (
	IceCandidatePairConfig_IPV4                   IceCandidatePairConfig_AddressFamily = 0
	IceCandidatePairConfig_IPV6                   IceCandidatePairConfig_AddressFamily = 1
	IceCandidatePairConfig_UNKNOWN_ADDRESS_FAMILY IceCandidatePairConfig_AddressFamily = 2
)

var IceCandidatePairConfig_AddressFamily_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
	2: "UNKNOWN_ADDRESS_FAMILY",
}
var IceCandidatePairConfig_AddressFamily_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
	"UNKNOWN_ADDRESS_FAMILY": 2,
}

func (x IceCandidatePairConfig_AddressFamily) Enum() *IceCandidatePairConfig_AddressFamily {
	p := new(IceCandidatePairConfig_AddressFamily)
	*p = x
	return p
}
func (x IceCandidatePairConfig_AddressFamily) String() string {
	return proto.EnumName(IceCandidatePairConfig_AddressFamily_name, int32(x))
}
func (x *IceCandidatePairConfig_AddressFamily) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IceCandidatePairConfig_AddressFamily_value, data, "IceCandidatePairConfig_AddressFamily")
	if err != nil {
		return err
	}
	*x = IceCandidatePairConfig_AddressFamily(value)
	return nil
}
func (IceCandidatePairConfig_AddressFamily) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 3}
}

type IceCandidatePairConfig_NetworkType int32

const (
	IceCandidatePairConfig_ETHERNET             IceCandidatePairConfig_NetworkType = 0
	IceCandidatePairConfig_LOOPBACK             IceCandidatePairConfig_NetworkType = 1
	IceCandidatePairConfig_WIFI                 IceCandidatePairConfig_NetworkType = 2
	IceCandidatePairConfig_VPN                  IceCandidatePairConfig_NetworkType = 3
	IceCandidatePairConfig_CELLULAR             IceCandidatePairConfig_NetworkType = 4
	IceCandidatePairConfig_UNKNOWN_NETWORK_TYPE IceCandidatePairConfig_NetworkType = 5
)

var IceCandidatePairConfig_NetworkType_name = map[int32]string{
	0: "ETHERNET",
	1: "LOOPBACK",
	2: "WIFI",
	3: "VPN",
	4: "CELLULAR",
	5: "UNKNOWN_NETWORK_TYPE",
}
var IceCandidatePairConfig_NetworkType_value = map[string]int32{
	"ETHERNET":             0,
	"LOOPBACK":             1,
	"WIFI":                 2,
	"VPN":                  3,
	"CELLULAR":             4,
	"UNKNOWN_NETWORK_TYPE": 5,
}

func (x IceCandidatePairConfig_NetworkType) Enum() *IceCandidatePairConfig_NetworkType {
	p := new(IceCandidatePairConfig_NetworkType)
	*p = x
	return p
}
func (x IceCandidatePairConfig_NetworkType) String() string {
	return proto.EnumName(IceCandidatePairConfig_NetworkType_name, int32(x))
}
func (x *IceCandidatePairConfig_NetworkType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IceCandidatePairConfig_NetworkType_value, data, "IceCandidatePairConfig_NetworkType")
	if err != nil {
		return err
	}
	*x = IceCandidatePairConfig_NetworkType(value)
	return nil
}
func (IceCandidatePairConfig_NetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 4}
}

type IceCandidatePairEvent_IceCandidatePairEventType int32

const (
	IceCandidatePairEvent_CHECK_SENT              IceCandidatePairEvent_IceCandidatePairEventType = 0
	IceCandidatePairEvent_CHECK_RECEIVED          IceCandidatePairEvent_IceCandidatePairEventType = 1
	IceCandidatePairEvent_CHECK_RESPONSE_SENT     IceCandidatePairEvent_IceCandidatePairEventType = 2
	IceCandidatePairEvent_CHECK_RESPONSE_RECEIVED IceCandidatePairEvent_IceCandidatePairEventType = 3
)

var IceCandidatePairEvent_IceCandidatePairEventType_name = map[int32]string{
	0: "CHECK_SENT",
	1: "CHECK_RECEIVED",
	2: "CHECK_RESPONSE_SENT",
	3: "CHECK_RESPONSE_RECEIVED",
}
var IceCandidatePairEvent_IceCandidatePairEventType_value = map[string]int32{
	"CHECK_SENT":              0,
	"CHECK_RECEIVED":          1,
	"CHECK_RESPONSE_SENT":     2,
	"CHECK_RESPONSE_RECEIVED": 3,
}

func (x IceCandidatePairEvent_IceCandidatePairEventType) Enum() *IceCandidatePairEvent_IceCandidatePairEventType {
	p := new(IceCandidatePairEvent_IceCandidatePairEventType)
	*p = x
	return p
}
func (x IceCandidatePairEvent_IceCandidatePairEventType) String() string {
	return proto.EnumName(IceCandidatePairEvent_IceCandidatePairEventType_name, int32(x))
}
func (x *IceCandidatePairEvent_IceCandidatePairEventType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IceCandidatePairEvent_IceCandidatePairEventType_value, data, "IceCandidatePairEvent_IceCandidatePairEventType")
	if err != nil {
		return err
	}
	*x = IceCandidatePairEvent_IceCandidatePairEventType(value)
	return nil
}
func (IceCandidatePairEvent_IceCandidatePairEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{21, 0}
}

// This is the main message to dump to a file, it can contain multiple event
// messages, but it is possible to append multiple EventStreams (each with a
// single event) to a file.
// This has the benefit that there's no need to keep all data in memory.
type EventStream struct {
	Stream           []*Event `protobuf:"bytes,1,rep,name=stream" json:"stream,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EventStream) Reset()                    { *m = EventStream{} }
func (m *EventStream) String() string            { return proto.CompactTextString(m) }
func (*EventStream) ProtoMessage()               {}
func (*EventStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EventStream) GetStream() []*Event {
	if m != nil {
		return m.Stream
	}
	return nil
}

type Event struct {
	// required - Elapsed wallclock time in us since the start of the log.
	TimestampUs *int64 `protobuf:"varint,1,opt,name=timestamp_us,json=timestampUs" json:"timestamp_us,omitempty"`
	// required - Indicates the type of this event
	Type *Event_EventType `protobuf:"varint,2,opt,name=type,enum=webrtc.rtclog.Event_EventType" json:"type,omitempty"`
	// Types that are valid to be assigned to Subtype:
	//	*Event_RtpPacket
	//	*Event_RtcpPacket
	//	*Event_AudioPlayoutEvent
	//	*Event_LossBasedBweUpdate
	//	*Event_DelayBasedBweUpdate
	//	*Event_VideoReceiverConfig
	//	*Event_VideoSenderConfig
	//	*Event_AudioReceiverConfig
	//	*Event_AudioSenderConfig
	//	*Event_AudioNetworkAdaptation
	//	*Event_ProbeCluster
	//	*Event_ProbeResult
	//	*Event_AlrState
	//	*Event_IceCandidatePairConfig
	//	*Event_IceCandidatePairEvent
	Subtype          isEvent_Subtype `protobuf_oneof:"subtype"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isEvent_Subtype interface {
	isEvent_Subtype()
}

type Event_RtpPacket struct {
	RtpPacket *RtpPacket `protobuf:"bytes,3,opt,name=rtp_packet,json=rtpPacket,oneof"`
}
type Event_RtcpPacket struct {
	RtcpPacket *RtcpPacket `protobuf:"bytes,4,opt,name=rtcp_packet,json=rtcpPacket,oneof"`
}
type Event_AudioPlayoutEvent struct {
	AudioPlayoutEvent *AudioPlayoutEvent `protobuf:"bytes,5,opt,name=audio_playout_event,json=audioPlayoutEvent,oneof"`
}
type Event_LossBasedBweUpdate struct {
	LossBasedBweUpdate *LossBasedBweUpdate `protobuf:"bytes,6,opt,name=loss_based_bwe_update,json=lossBasedBweUpdate,oneof"`
}
type Event_DelayBasedBweUpdate struct {
	DelayBasedBweUpdate *DelayBasedBweUpdate `protobuf:"bytes,7,opt,name=delay_based_bwe_update,json=delayBasedBweUpdate,oneof"`
}
type Event_VideoReceiverConfig struct {
	VideoReceiverConfig *VideoReceiveConfig `protobuf:"bytes,8,opt,name=video_receiver_config,json=videoReceiverConfig,oneof"`
}
type Event_VideoSenderConfig struct {
	VideoSenderConfig *VideoSendConfig `protobuf:"bytes,9,opt,name=video_sender_config,json=videoSenderConfig,oneof"`
}
type Event_AudioReceiverConfig struct {
	AudioReceiverConfig *AudioReceiveConfig `protobuf:"bytes,10,opt,name=audio_receiver_config,json=audioReceiverConfig,oneof"`
}
type Event_AudioSenderConfig struct {
	AudioSenderConfig *AudioSendConfig `protobuf:"bytes,11,opt,name=audio_sender_config,json=audioSenderConfig,oneof"`
}
type Event_AudioNetworkAdaptation struct {
	AudioNetworkAdaptation *AudioNetworkAdaptation `protobuf:"bytes,16,opt,name=audio_network_adaptation,json=audioNetworkAdaptation,oneof"`
}
type Event_ProbeCluster struct {
	ProbeCluster *BweProbeCluster `protobuf:"bytes,17,opt,name=probe_cluster,json=probeCluster,oneof"`
}
type Event_ProbeResult struct {
	ProbeResult *BweProbeResult `protobuf:"bytes,18,opt,name=probe_result,json=probeResult,oneof"`
}
type Event_AlrState struct {
	AlrState *AlrState `protobuf:"bytes,19,opt,name=alr_state,json=alrState,oneof"`
}
type Event_IceCandidatePairConfig struct {
	IceCandidatePairConfig *IceCandidatePairConfig `protobuf:"bytes,20,opt,name=ice_candidate_pair_config,json=iceCandidatePairConfig,oneof"`
}
type Event_IceCandidatePairEvent struct {
	IceCandidatePairEvent *IceCandidatePairEvent `protobuf:"bytes,21,opt,name=ice_candidate_pair_event,json=iceCandidatePairEvent,oneof"`
}

func (*Event_RtpPacket) isEvent_Subtype()              {}
func (*Event_RtcpPacket) isEvent_Subtype()             {}
func (*Event_AudioPlayoutEvent) isEvent_Subtype()      {}
func (*Event_LossBasedBweUpdate) isEvent_Subtype()     {}
func (*Event_DelayBasedBweUpdate) isEvent_Subtype()    {}
func (*Event_VideoReceiverConfig) isEvent_Subtype()    {}
func (*Event_VideoSenderConfig) isEvent_Subtype()      {}
func (*Event_AudioReceiverConfig) isEvent_Subtype()    {}
func (*Event_AudioSenderConfig) isEvent_Subtype()      {}
func (*Event_AudioNetworkAdaptation) isEvent_Subtype() {}
func (*Event_ProbeCluster) isEvent_Subtype()           {}
func (*Event_ProbeResult) isEvent_Subtype()            {}
func (*Event_AlrState) isEvent_Subtype()               {}
func (*Event_IceCandidatePairConfig) isEvent_Subtype() {}
func (*Event_IceCandidatePairEvent) isEvent_Subtype()  {}

func (m *Event) GetSubtype() isEvent_Subtype {
	if m != nil {
		return m.Subtype
	}
	return nil
}

func (m *Event) GetTimestampUs() int64 {
	if m != nil && m.TimestampUs != nil {
		return *m.TimestampUs
	}
	return 0
}

func (m *Event) GetType() Event_EventType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_UNKNOWN_EVENT
}

func (m *Event) GetRtpPacket() *RtpPacket {
	if x, ok := m.GetSubtype().(*Event_RtpPacket); ok {
		return x.RtpPacket
	}
	return nil
}

func (m *Event) GetRtcpPacket() *RtcpPacket {
	if x, ok := m.GetSubtype().(*Event_RtcpPacket); ok {
		return x.RtcpPacket
	}
	return nil
}

func (m *Event) GetAudioPlayoutEvent() *AudioPlayoutEvent {
	if x, ok := m.GetSubtype().(*Event_AudioPlayoutEvent); ok {
		return x.AudioPlayoutEvent
	}
	return nil
}

func (m *Event) GetLossBasedBweUpdate() *LossBasedBweUpdate {
	if x, ok := m.GetSubtype().(*Event_LossBasedBweUpdate); ok {
		return x.LossBasedBweUpdate
	}
	return nil
}

func (m *Event) GetDelayBasedBweUpdate() *DelayBasedBweUpdate {
	if x, ok := m.GetSubtype().(*Event_DelayBasedBweUpdate); ok {
		return x.DelayBasedBweUpdate
	}
	return nil
}

func (m *Event) GetVideoReceiverConfig() *VideoReceiveConfig {
	if x, ok := m.GetSubtype().(*Event_VideoReceiverConfig); ok {
		return x.VideoReceiverConfig
	}
	return nil
}

func (m *Event) GetVideoSenderConfig() *VideoSendConfig {
	if x, ok := m.GetSubtype().(*Event_VideoSenderConfig); ok {
		return x.VideoSenderConfig
	}
	return nil
}

func (m *Event) GetAudioReceiverConfig() *AudioReceiveConfig {
	if x, ok := m.GetSubtype().(*Event_AudioReceiverConfig); ok {
		return x.AudioReceiverConfig
	}
	return nil
}

func (m *Event) GetAudioSenderConfig() *AudioSendConfig {
	if x, ok := m.GetSubtype().(*Event_AudioSenderConfig); ok {
		return x.AudioSenderConfig
	}
	return nil
}

func (m *Event) GetAudioNetworkAdaptation() *AudioNetworkAdaptation {
	if x, ok := m.GetSubtype().(*Event_AudioNetworkAdaptation); ok {
		return x.AudioNetworkAdaptation
	}
	return nil
}

func (m *Event) GetProbeCluster() *BweProbeCluster {
	if x, ok := m.GetSubtype().(*Event_ProbeCluster); ok {
		return x.ProbeCluster
	}
	return nil
}

func (m *Event) GetProbeResult() *BweProbeResult {
	if x, ok := m.GetSubtype().(*Event_ProbeResult); ok {
		return x.ProbeResult
	}
	return nil
}

func (m *Event) GetAlrState() *AlrState {
	if x, ok := m.GetSubtype().(*Event_AlrState); ok {
		return x.AlrState
	}
	return nil
}

func (m *Event) GetIceCandidatePairConfig() *IceCandidatePairConfig {
	if x, ok := m.GetSubtype().(*Event_IceCandidatePairConfig); ok {
		return x.IceCandidatePairConfig
	}
	return nil
}

func (m *Event) GetIceCandidatePairEvent() *IceCandidatePairEvent {
	if x, ok := m.GetSubtype().(*Event_IceCandidatePairEvent); ok {
		return x.IceCandidatePairEvent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Event) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Event_OneofMarshaler, _Event_OneofUnmarshaler, _Event_OneofSizer, []interface{}{
		(*Event_RtpPacket)(nil),
		(*Event_RtcpPacket)(nil),
		(*Event_AudioPlayoutEvent)(nil),
		(*Event_LossBasedBweUpdate)(nil),
		(*Event_DelayBasedBweUpdate)(nil),
		(*Event_VideoReceiverConfig)(nil),
		(*Event_VideoSenderConfig)(nil),
		(*Event_AudioReceiverConfig)(nil),
		(*Event_AudioSenderConfig)(nil),
		(*Event_AudioNetworkAdaptation)(nil),
		(*Event_ProbeCluster)(nil),
		(*Event_ProbeResult)(nil),
		(*Event_AlrState)(nil),
		(*Event_IceCandidatePairConfig)(nil),
		(*Event_IceCandidatePairEvent)(nil),
	}
}

func _Event_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Event)
	// subtype
	switch x := m.Subtype.(type) {
	case *Event_RtpPacket:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RtpPacket); err != nil {
			return err
		}
	case *Event_RtcpPacket:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RtcpPacket); err != nil {
			return err
		}
	case *Event_AudioPlayoutEvent:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AudioPlayoutEvent); err != nil {
			return err
		}
	case *Event_LossBasedBweUpdate:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LossBasedBweUpdate); err != nil {
			return err
		}
	case *Event_DelayBasedBweUpdate:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DelayBasedBweUpdate); err != nil {
			return err
		}
	case *Event_VideoReceiverConfig:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VideoReceiverConfig); err != nil {
			return err
		}
	case *Event_VideoSenderConfig:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VideoSenderConfig); err != nil {
			return err
		}
	case *Event_AudioReceiverConfig:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AudioReceiverConfig); err != nil {
			return err
		}
	case *Event_AudioSenderConfig:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AudioSenderConfig); err != nil {
			return err
		}
	case *Event_AudioNetworkAdaptation:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AudioNetworkAdaptation); err != nil {
			return err
		}
	case *Event_ProbeCluster:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProbeCluster); err != nil {
			return err
		}
	case *Event_ProbeResult:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProbeResult); err != nil {
			return err
		}
	case *Event_AlrState:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AlrState); err != nil {
			return err
		}
	case *Event_IceCandidatePairConfig:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IceCandidatePairConfig); err != nil {
			return err
		}
	case *Event_IceCandidatePairEvent:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IceCandidatePairEvent); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Event.Subtype has unexpected type %T", x)
	}
	return nil
}

func _Event_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Event)
	switch tag {
	case 3: // subtype.rtp_packet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RtpPacket)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_RtpPacket{msg}
		return true, err
	case 4: // subtype.rtcp_packet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RtcpPacket)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_RtcpPacket{msg}
		return true, err
	case 5: // subtype.audio_playout_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AudioPlayoutEvent)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_AudioPlayoutEvent{msg}
		return true, err
	case 6: // subtype.loss_based_bwe_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LossBasedBweUpdate)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_LossBasedBweUpdate{msg}
		return true, err
	case 7: // subtype.delay_based_bwe_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DelayBasedBweUpdate)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_DelayBasedBweUpdate{msg}
		return true, err
	case 8: // subtype.video_receiver_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoReceiveConfig)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_VideoReceiverConfig{msg}
		return true, err
	case 9: // subtype.video_sender_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoSendConfig)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_VideoSenderConfig{msg}
		return true, err
	case 10: // subtype.audio_receiver_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AudioReceiveConfig)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_AudioReceiverConfig{msg}
		return true, err
	case 11: // subtype.audio_sender_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AudioSendConfig)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_AudioSenderConfig{msg}
		return true, err
	case 16: // subtype.audio_network_adaptation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AudioNetworkAdaptation)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_AudioNetworkAdaptation{msg}
		return true, err
	case 17: // subtype.probe_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BweProbeCluster)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_ProbeCluster{msg}
		return true, err
	case 18: // subtype.probe_result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BweProbeResult)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_ProbeResult{msg}
		return true, err
	case 19: // subtype.alr_state
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AlrState)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_AlrState{msg}
		return true, err
	case 20: // subtype.ice_candidate_pair_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IceCandidatePairConfig)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_IceCandidatePairConfig{msg}
		return true, err
	case 21: // subtype.ice_candidate_pair_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IceCandidatePairEvent)
		err := b.DecodeMessage(msg)
		m.Subtype = &Event_IceCandidatePairEvent{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Event_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Event)
	// subtype
	switch x := m.Subtype.(type) {
	case *Event_RtpPacket:
		s := proto.Size(x.RtpPacket)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_RtcpPacket:
		s := proto.Size(x.RtcpPacket)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_AudioPlayoutEvent:
		s := proto.Size(x.AudioPlayoutEvent)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_LossBasedBweUpdate:
		s := proto.Size(x.LossBasedBweUpdate)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_DelayBasedBweUpdate:
		s := proto.Size(x.DelayBasedBweUpdate)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_VideoReceiverConfig:
		s := proto.Size(x.VideoReceiverConfig)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_VideoSenderConfig:
		s := proto.Size(x.VideoSenderConfig)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_AudioReceiverConfig:
		s := proto.Size(x.AudioReceiverConfig)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_AudioSenderConfig:
		s := proto.Size(x.AudioSenderConfig)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_AudioNetworkAdaptation:
		s := proto.Size(x.AudioNetworkAdaptation)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_ProbeCluster:
		s := proto.Size(x.ProbeCluster)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_ProbeResult:
		s := proto.Size(x.ProbeResult)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_AlrState:
		s := proto.Size(x.AlrState)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_IceCandidatePairConfig:
		s := proto.Size(x.IceCandidatePairConfig)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_IceCandidatePairEvent:
		s := proto.Size(x.IceCandidatePairEvent)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RtpPacket struct {
	// required - True if the packet is incoming w.r.t. the user logging the data
	Incoming *bool      `protobuf:"varint,1,opt,name=incoming" json:"incoming,omitempty"`
	Type     *MediaType `protobuf:"varint,2,opt,name=type,enum=webrtc.rtclog.MediaType" json:"type,omitempty"`
	// required - The size of the packet including both payload and header.
	PacketLength *uint32 `protobuf:"varint,3,opt,name=packet_length,json=packetLength" json:"packet_length,omitempty"`
	// required - The RTP header only.
	Header []byte `protobuf:"bytes,4,opt,name=header" json:"header,omitempty"`
	// optional - The probe cluster id.
	ProbeClusterId   *int32 `protobuf:"varint,5,opt,name=probe_cluster_id,json=probeClusterId" json:"probe_cluster_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RtpPacket) Reset()                    { *m = RtpPacket{} }
func (m *RtpPacket) String() string            { return proto.CompactTextString(m) }
func (*RtpPacket) ProtoMessage()               {}
func (*RtpPacket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RtpPacket) GetIncoming() bool {
	if m != nil && m.Incoming != nil {
		return *m.Incoming
	}
	return false
}

func (m *RtpPacket) GetType() MediaType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MediaType_ANY
}

func (m *RtpPacket) GetPacketLength() uint32 {
	if m != nil && m.PacketLength != nil {
		return *m.PacketLength
	}
	return 0
}

func (m *RtpPacket) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RtpPacket) GetProbeClusterId() int32 {
	if m != nil && m.ProbeClusterId != nil {
		return *m.ProbeClusterId
	}
	return 0
}

type RtcpPacket struct {
	// required - True if the packet is incoming w.r.t. the user logging the data
	Incoming *bool      `protobuf:"varint,1,opt,name=incoming" json:"incoming,omitempty"`
	Type     *MediaType `protobuf:"varint,2,opt,name=type,enum=webrtc.rtclog.MediaType" json:"type,omitempty"`
	// required - The whole packet including both payload and header.
	PacketData       []byte `protobuf:"bytes,3,opt,name=packet_data,json=packetData" json:"packet_data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RtcpPacket) Reset()                    { *m = RtcpPacket{} }
func (m *RtcpPacket) String() string            { return proto.CompactTextString(m) }
func (*RtcpPacket) ProtoMessage()               {}
func (*RtcpPacket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RtcpPacket) GetIncoming() bool {
	if m != nil && m.Incoming != nil {
		return *m.Incoming
	}
	return false
}

func (m *RtcpPacket) GetType() MediaType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MediaType_ANY
}

func (m *RtcpPacket) GetPacketData() []byte {
	if m != nil {
		return m.PacketData
	}
	return nil
}

type AudioPlayoutEvent struct {
	// TODO(ivoc): Rename, we currently use the "remote" ssrc, i.e. identifying
	// the receive stream, while local_ssrc identifies the send stream, if any.
	// required - The SSRC of the audio stream associated with the playout event.
	LocalSsrc        *uint32 `protobuf:"varint,2,opt,name=local_ssrc,json=localSsrc" json:"local_ssrc,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AudioPlayoutEvent) Reset()                    { *m = AudioPlayoutEvent{} }
func (m *AudioPlayoutEvent) String() string            { return proto.CompactTextString(m) }
func (*AudioPlayoutEvent) ProtoMessage()               {}
func (*AudioPlayoutEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AudioPlayoutEvent) GetLocalSsrc() uint32 {
	if m != nil && m.LocalSsrc != nil {
		return *m.LocalSsrc
	}
	return 0
}

type LossBasedBweUpdate struct {
	// required - Bandwidth estimate (in bps) after the update.
	BitrateBps *int32 `protobuf:"varint,1,opt,name=bitrate_bps,json=bitrateBps" json:"bitrate_bps,omitempty"`
	// required - Fraction of lost packets since last receiver report
	// computed as floor( 256 * (#lost_packets / #total_packets) ).
	// The possible values range from 0 to 255.
	FractionLoss *uint32 `protobuf:"varint,2,opt,name=fraction_loss,json=fractionLoss" json:"fraction_loss,omitempty"`
	// TODO(terelius): Is this really needed? Remove or make optional?
	// required - Total number of packets that the BWE update is based on.
	TotalPackets     *int32 `protobuf:"varint,3,opt,name=total_packets,json=totalPackets" json:"total_packets,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LossBasedBweUpdate) Reset()                    { *m = LossBasedBweUpdate{} }
func (m *LossBasedBweUpdate) String() string            { return proto.CompactTextString(m) }
func (*LossBasedBweUpdate) ProtoMessage()               {}
func (*LossBasedBweUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LossBasedBweUpdate) GetBitrateBps() int32 {
	if m != nil && m.BitrateBps != nil {
		return *m.BitrateBps
	}
	return 0
}

func (m *LossBasedBweUpdate) GetFractionLoss() uint32 {
	if m != nil && m.FractionLoss != nil {
		return *m.FractionLoss
	}
	return 0
}

func (m *LossBasedBweUpdate) GetTotalPackets() int32 {
	if m != nil && m.TotalPackets != nil {
		return *m.TotalPackets
	}
	return 0
}

type DelayBasedBweUpdate struct {
	// required - Bandwidth estimate (in bps) after the update.
	BitrateBps *int32 `protobuf:"varint,1,opt,name=bitrate_bps,json=bitrateBps" json:"bitrate_bps,omitempty"`
	// required - The state of the overuse detector.
	DetectorState    *DelayBasedBweUpdate_DetectorState `protobuf:"varint,2,opt,name=detector_state,json=detectorState,enum=webrtc.rtclog.DelayBasedBweUpdate_DetectorState" json:"detector_state,omitempty"`
	XXX_unrecognized []byte                             `json:"-"`
}

func (m *DelayBasedBweUpdate) Reset()                    { *m = DelayBasedBweUpdate{} }
func (m *DelayBasedBweUpdate) String() string            { return proto.CompactTextString(m) }
func (*DelayBasedBweUpdate) ProtoMessage()               {}
func (*DelayBasedBweUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DelayBasedBweUpdate) GetBitrateBps() int32 {
	if m != nil && m.BitrateBps != nil {
		return *m.BitrateBps
	}
	return 0
}

func (m *DelayBasedBweUpdate) GetDetectorState() DelayBasedBweUpdate_DetectorState {
	if m != nil && m.DetectorState != nil {
		return *m.DetectorState
	}
	return DelayBasedBweUpdate_BWE_NORMAL
}

// TODO(terelius): Video and audio streams could in principle share SSRC,
// so identifying a stream based only on SSRC might not work.
// It might be better to use a combination of SSRC and media type
// or SSRC and port number, but for now we will rely on SSRC only.
type VideoReceiveConfig struct {
	// required - Synchronization source (stream identifier) to be received.
	RemoteSsrc *uint32 `protobuf:"varint,1,opt,name=remote_ssrc,json=remoteSsrc" json:"remote_ssrc,omitempty"`
	// required - Sender SSRC used for sending RTCP (such as receiver reports).
	LocalSsrc *uint32 `protobuf:"varint,2,opt,name=local_ssrc,json=localSsrc" json:"local_ssrc,omitempty"`
	// required - RTCP mode to use.
	RtcpMode *VideoReceiveConfig_RtcpMode `protobuf:"varint,3,opt,name=rtcp_mode,json=rtcpMode,enum=webrtc.rtclog.VideoReceiveConfig_RtcpMode" json:"rtcp_mode,omitempty"`
	// required - Receiver estimated maximum bandwidth.
	Remb *bool `protobuf:"varint,4,opt,name=remb" json:"remb,omitempty"`
	// Map from video RTP payload type -> RTX config.
	RtxMap []*RtxMap `protobuf:"bytes,5,rep,name=rtx_map,json=rtxMap" json:"rtx_map,omitempty"`
	// RTP header extensions used for the received stream.
	HeaderExtensions []*RtpHeaderExtension `protobuf:"bytes,6,rep,name=header_extensions,json=headerExtensions" json:"header_extensions,omitempty"`
	// List of decoders associated with the stream.
	Decoders         []*DecoderConfig `protobuf:"bytes,7,rep,name=decoders" json:"decoders,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *VideoReceiveConfig) Reset()                    { *m = VideoReceiveConfig{} }
func (m *VideoReceiveConfig) String() string            { return proto.CompactTextString(m) }
func (*VideoReceiveConfig) ProtoMessage()               {}
func (*VideoReceiveConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *VideoReceiveConfig) GetRemoteSsrc() uint32 {
	if m != nil && m.RemoteSsrc != nil {
		return *m.RemoteSsrc
	}
	return 0
}

func (m *VideoReceiveConfig) GetLocalSsrc() uint32 {
	if m != nil && m.LocalSsrc != nil {
		return *m.LocalSsrc
	}
	return 0
}

func (m *VideoReceiveConfig) GetRtcpMode() VideoReceiveConfig_RtcpMode {
	if m != nil && m.RtcpMode != nil {
		return *m.RtcpMode
	}
	return VideoReceiveConfig_RTCP_COMPOUND
}

func (m *VideoReceiveConfig) GetRemb() bool {
	if m != nil && m.Remb != nil {
		return *m.Remb
	}
	return false
}

func (m *VideoReceiveConfig) GetRtxMap() []*RtxMap {
	if m != nil {
		return m.RtxMap
	}
	return nil
}

func (m *VideoReceiveConfig) GetHeaderExtensions() []*RtpHeaderExtension {
	if m != nil {
		return m.HeaderExtensions
	}
	return nil
}

func (m *VideoReceiveConfig) GetDecoders() []*DecoderConfig {
	if m != nil {
		return m.Decoders
	}
	return nil
}

// Maps decoder names to payload types.
type DecoderConfig struct {
	// required
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// required
	PayloadType      *int32 `protobuf:"varint,2,opt,name=payload_type,json=payloadType" json:"payload_type,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DecoderConfig) Reset()                    { *m = DecoderConfig{} }
func (m *DecoderConfig) String() string            { return proto.CompactTextString(m) }
func (*DecoderConfig) ProtoMessage()               {}
func (*DecoderConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DecoderConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DecoderConfig) GetPayloadType() int32 {
	if m != nil && m.PayloadType != nil {
		return *m.PayloadType
	}
	return 0
}

// Maps RTP header extension names to numerical IDs.
type RtpHeaderExtension struct {
	// required
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// required
	Id               *int32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RtpHeaderExtension) Reset()                    { *m = RtpHeaderExtension{} }
func (m *RtpHeaderExtension) String() string            { return proto.CompactTextString(m) }
func (*RtpHeaderExtension) ProtoMessage()               {}
func (*RtpHeaderExtension) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RtpHeaderExtension) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *RtpHeaderExtension) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

// RTX settings for incoming video payloads that may be received.
// RTX is disabled if there's no config present.
type RtxConfig struct {
	// required - SSRC to use for the RTX stream.
	RtxSsrc *uint32 `protobuf:"varint,1,opt,name=rtx_ssrc,json=rtxSsrc" json:"rtx_ssrc,omitempty"`
	// required - Payload type to use for the RTX stream.
	RtxPayloadType   *int32 `protobuf:"varint,2,opt,name=rtx_payload_type,json=rtxPayloadType" json:"rtx_payload_type,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RtxConfig) Reset()                    { *m = RtxConfig{} }
func (m *RtxConfig) String() string            { return proto.CompactTextString(m) }
func (*RtxConfig) ProtoMessage()               {}
func (*RtxConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *RtxConfig) GetRtxSsrc() uint32 {
	if m != nil && m.RtxSsrc != nil {
		return *m.RtxSsrc
	}
	return 0
}

func (m *RtxConfig) GetRtxPayloadType() int32 {
	if m != nil && m.RtxPayloadType != nil {
		return *m.RtxPayloadType
	}
	return 0
}

type RtxMap struct {
	// required
	PayloadType *int32 `protobuf:"varint,1,opt,name=payload_type,json=payloadType" json:"payload_type,omitempty"`
	// required
	Config           *RtxConfig `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *RtxMap) Reset()                    { *m = RtxMap{} }
func (m *RtxMap) String() string            { return proto.CompactTextString(m) }
func (*RtxMap) ProtoMessage()               {}
func (*RtxMap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RtxMap) GetPayloadType() int32 {
	if m != nil && m.PayloadType != nil {
		return *m.PayloadType
	}
	return 0
}

func (m *RtxMap) GetConfig() *RtxConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

type VideoSendConfig struct {
	// Synchronization source (stream identifier) for outgoing stream.
	// One stream can have several ssrcs for e.g. simulcast.
	// At least one ssrc is required.
	Ssrcs []uint32 `protobuf:"varint,1,rep,name=ssrcs" json:"ssrcs,omitempty"`
	// RTP header extensions used for the outgoing stream.
	HeaderExtensions []*RtpHeaderExtension `protobuf:"bytes,2,rep,name=header_extensions,json=headerExtensions" json:"header_extensions,omitempty"`
	// List of SSRCs for retransmitted packets.
	RtxSsrcs []uint32 `protobuf:"varint,3,rep,name=rtx_ssrcs,json=rtxSsrcs" json:"rtx_ssrcs,omitempty"`
	// required if rtx_ssrcs is used - Payload type for retransmitted packets.
	RtxPayloadType *int32 `protobuf:"varint,4,opt,name=rtx_payload_type,json=rtxPayloadType" json:"rtx_payload_type,omitempty"`
	// required - Encoder associated with the stream.
	Encoder          *EncoderConfig `protobuf:"bytes,5,opt,name=encoder" json:"encoder,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *VideoSendConfig) Reset()                    { *m = VideoSendConfig{} }
func (m *VideoSendConfig) String() string            { return proto.CompactTextString(m) }
func (*VideoSendConfig) ProtoMessage()               {}
func (*VideoSendConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *VideoSendConfig) GetSsrcs() []uint32 {
	if m != nil {
		return m.Ssrcs
	}
	return nil
}

func (m *VideoSendConfig) GetHeaderExtensions() []*RtpHeaderExtension {
	if m != nil {
		return m.HeaderExtensions
	}
	return nil
}

func (m *VideoSendConfig) GetRtxSsrcs() []uint32 {
	if m != nil {
		return m.RtxSsrcs
	}
	return nil
}

func (m *VideoSendConfig) GetRtxPayloadType() int32 {
	if m != nil && m.RtxPayloadType != nil {
		return *m.RtxPayloadType
	}
	return 0
}

func (m *VideoSendConfig) GetEncoder() *EncoderConfig {
	if m != nil {
		return m.Encoder
	}
	return nil
}

// Maps encoder names to payload types.
type EncoderConfig struct {
	// required
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// required
	PayloadType      *int32 `protobuf:"varint,2,opt,name=payload_type,json=payloadType" json:"payload_type,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EncoderConfig) Reset()                    { *m = EncoderConfig{} }
func (m *EncoderConfig) String() string            { return proto.CompactTextString(m) }
func (*EncoderConfig) ProtoMessage()               {}
func (*EncoderConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *EncoderConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EncoderConfig) GetPayloadType() int32 {
	if m != nil && m.PayloadType != nil {
		return *m.PayloadType
	}
	return 0
}

type AudioReceiveConfig struct {
	// required - Synchronization source (stream identifier) to be received.
	RemoteSsrc *uint32 `protobuf:"varint,1,opt,name=remote_ssrc,json=remoteSsrc" json:"remote_ssrc,omitempty"`
	// required - Sender SSRC used for sending RTCP (such as receiver reports).
	LocalSsrc *uint32 `protobuf:"varint,2,opt,name=local_ssrc,json=localSsrc" json:"local_ssrc,omitempty"`
	// RTP header extensions used for the received audio stream.
	HeaderExtensions []*RtpHeaderExtension `protobuf:"bytes,3,rep,name=header_extensions,json=headerExtensions" json:"header_extensions,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *AudioReceiveConfig) Reset()                    { *m = AudioReceiveConfig{} }
func (m *AudioReceiveConfig) String() string            { return proto.CompactTextString(m) }
func (*AudioReceiveConfig) ProtoMessage()               {}
func (*AudioReceiveConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AudioReceiveConfig) GetRemoteSsrc() uint32 {
	if m != nil && m.RemoteSsrc != nil {
		return *m.RemoteSsrc
	}
	return 0
}

func (m *AudioReceiveConfig) GetLocalSsrc() uint32 {
	if m != nil && m.LocalSsrc != nil {
		return *m.LocalSsrc
	}
	return 0
}

func (m *AudioReceiveConfig) GetHeaderExtensions() []*RtpHeaderExtension {
	if m != nil {
		return m.HeaderExtensions
	}
	return nil
}

type AudioSendConfig struct {
	// required - Synchronization source (stream identifier) for outgoing stream.
	Ssrc *uint32 `protobuf:"varint,1,opt,name=ssrc" json:"ssrc,omitempty"`
	// RTP header extensions used for the outgoing audio stream.
	HeaderExtensions []*RtpHeaderExtension `protobuf:"bytes,2,rep,name=header_extensions,json=headerExtensions" json:"header_extensions,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *AudioSendConfig) Reset()                    { *m = AudioSendConfig{} }
func (m *AudioSendConfig) String() string            { return proto.CompactTextString(m) }
func (*AudioSendConfig) ProtoMessage()               {}
func (*AudioSendConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *AudioSendConfig) GetSsrc() uint32 {
	if m != nil && m.Ssrc != nil {
		return *m.Ssrc
	}
	return 0
}

func (m *AudioSendConfig) GetHeaderExtensions() []*RtpHeaderExtension {
	if m != nil {
		return m.HeaderExtensions
	}
	return nil
}

type AudioNetworkAdaptation struct {
	// Bit rate that the audio encoder is operating at.
	BitrateBps *int32 `protobuf:"varint,1,opt,name=bitrate_bps,json=bitrateBps" json:"bitrate_bps,omitempty"`
	// Frame length that each encoded audio packet consists of.
	FrameLengthMs *int32 `protobuf:"varint,2,opt,name=frame_length_ms,json=frameLengthMs" json:"frame_length_ms,omitempty"`
	// Packet loss fraction that the encoder's forward error correction (FEC) is
	// optimized for.
	UplinkPacketLossFraction *float32 `protobuf:"fixed32,3,opt,name=uplink_packet_loss_fraction,json=uplinkPacketLossFraction" json:"uplink_packet_loss_fraction,omitempty"`
	// Whether forward error correction (FEC) is turned on or off.
	EnableFec *bool `protobuf:"varint,4,opt,name=enable_fec,json=enableFec" json:"enable_fec,omitempty"`
	// Whether discontinuous transmission (DTX) is turned on or off.
	EnableDtx *bool `protobuf:"varint,5,opt,name=enable_dtx,json=enableDtx" json:"enable_dtx,omitempty"`
	// Number of audio channels that each encoded packet consists of.
	NumChannels      *uint32 `protobuf:"varint,6,opt,name=num_channels,json=numChannels" json:"num_channels,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AudioNetworkAdaptation) Reset()                    { *m = AudioNetworkAdaptation{} }
func (m *AudioNetworkAdaptation) String() string            { return proto.CompactTextString(m) }
func (*AudioNetworkAdaptation) ProtoMessage()               {}
func (*AudioNetworkAdaptation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *AudioNetworkAdaptation) GetBitrateBps() int32 {
	if m != nil && m.BitrateBps != nil {
		return *m.BitrateBps
	}
	return 0
}

func (m *AudioNetworkAdaptation) GetFrameLengthMs() int32 {
	if m != nil && m.FrameLengthMs != nil {
		return *m.FrameLengthMs
	}
	return 0
}

func (m *AudioNetworkAdaptation) GetUplinkPacketLossFraction() float32 {
	if m != nil && m.UplinkPacketLossFraction != nil {
		return *m.UplinkPacketLossFraction
	}
	return 0
}

func (m *AudioNetworkAdaptation) GetEnableFec() bool {
	if m != nil && m.EnableFec != nil {
		return *m.EnableFec
	}
	return false
}

func (m *AudioNetworkAdaptation) GetEnableDtx() bool {
	if m != nil && m.EnableDtx != nil {
		return *m.EnableDtx
	}
	return false
}

func (m *AudioNetworkAdaptation) GetNumChannels() uint32 {
	if m != nil && m.NumChannels != nil {
		return *m.NumChannels
	}
	return 0
}

type BweProbeCluster struct {
	// required - The id of this probe cluster.
	Id *int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// required - The bitrate in bps that this probe cluster is meant to probe.
	BitrateBps *int32 `protobuf:"varint,2,opt,name=bitrate_bps,json=bitrateBps" json:"bitrate_bps,omitempty"`
	// required - The minimum number of packets used to probe the given bitrate.
	MinPackets *uint32 `protobuf:"varint,3,opt,name=min_packets,json=minPackets" json:"min_packets,omitempty"`
	// required - The minimum number of bytes used to probe the given bitrate.
	MinBytes         *uint32 `protobuf:"varint,4,opt,name=min_bytes,json=minBytes" json:"min_bytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BweProbeCluster) Reset()                    { *m = BweProbeCluster{} }
func (m *BweProbeCluster) String() string            { return proto.CompactTextString(m) }
func (*BweProbeCluster) ProtoMessage()               {}
func (*BweProbeCluster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *BweProbeCluster) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *BweProbeCluster) GetBitrateBps() int32 {
	if m != nil && m.BitrateBps != nil {
		return *m.BitrateBps
	}
	return 0
}

func (m *BweProbeCluster) GetMinPackets() uint32 {
	if m != nil && m.MinPackets != nil {
		return *m.MinPackets
	}
	return 0
}

func (m *BweProbeCluster) GetMinBytes() uint32 {
	if m != nil && m.MinBytes != nil {
		return *m.MinBytes
	}
	return 0
}

type BweProbeResult struct {
	// required - The id of this probe cluster.
	Id *int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// required - The result of this probing attempt.
	Result *BweProbeResult_ResultType `protobuf:"varint,2,opt,name=result,enum=webrtc.rtclog.BweProbeResult_ResultType" json:"result,omitempty"`
	// optional - but required if result == SUCCESS. The resulting bitrate in bps.
	BitrateBps       *int32 `protobuf:"varint,3,opt,name=bitrate_bps,json=bitrateBps" json:"bitrate_bps,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BweProbeResult) Reset()                    { *m = BweProbeResult{} }
func (m *BweProbeResult) String() string            { return proto.CompactTextString(m) }
func (*BweProbeResult) ProtoMessage()               {}
func (*BweProbeResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *BweProbeResult) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *BweProbeResult) GetResult() BweProbeResult_ResultType {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return BweProbeResult_SUCCESS
}

func (m *BweProbeResult) GetBitrateBps() int32 {
	if m != nil && m.BitrateBps != nil {
		return *m.BitrateBps
	}
	return 0
}

type AlrState struct {
	// required - If we are in ALR or not.
	InAlr            *bool  `protobuf:"varint,1,opt,name=in_alr,json=inAlr" json:"in_alr,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AlrState) Reset()                    { *m = AlrState{} }
func (m *AlrState) String() string            { return proto.CompactTextString(m) }
func (*AlrState) ProtoMessage()               {}
func (*AlrState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *AlrState) GetInAlr() bool {
	if m != nil && m.InAlr != nil {
		return *m.InAlr
	}
	return false
}

type IceCandidatePairConfig struct {
	// required
	ConfigType *IceCandidatePairConfig_IceCandidatePairConfigType `protobuf:"varint,1,opt,name=config_type,json=configType,enum=webrtc.rtclog.IceCandidatePairConfig_IceCandidatePairConfigType" json:"config_type,omitempty"`
	// required
	CandidatePairId *uint32 `protobuf:"varint,2,opt,name=candidate_pair_id,json=candidatePairId" json:"candidate_pair_id,omitempty"`
	// required
	LocalCandidateType *IceCandidatePairConfig_IceCandidateType `protobuf:"varint,3,opt,name=local_candidate_type,json=localCandidateType,enum=webrtc.rtclog.IceCandidatePairConfig_IceCandidateType" json:"local_candidate_type,omitempty"`
	// required
	LocalRelayProtocol *IceCandidatePairConfig_Protocol `protobuf:"varint,4,opt,name=local_relay_protocol,json=localRelayProtocol,enum=webrtc.rtclog.IceCandidatePairConfig_Protocol" json:"local_relay_protocol,omitempty"`
	// required
	LocalNetworkType *IceCandidatePairConfig_NetworkType `protobuf:"varint,5,opt,name=local_network_type,json=localNetworkType,enum=webrtc.rtclog.IceCandidatePairConfig_NetworkType" json:"local_network_type,omitempty"`
	// required
	LocalAddressFamily *IceCandidatePairConfig_AddressFamily `protobuf:"varint,6,opt,name=local_address_family,json=localAddressFamily,enum=webrtc.rtclog.IceCandidatePairConfig_AddressFamily" json:"local_address_family,omitempty"`
	// required
	RemoteCandidateType *IceCandidatePairConfig_IceCandidateType `protobuf:"varint,7,opt,name=remote_candidate_type,json=remoteCandidateType,enum=webrtc.rtclog.IceCandidatePairConfig_IceCandidateType" json:"remote_candidate_type,omitempty"`
	// required
	RemoteAddressFamily *IceCandidatePairConfig_AddressFamily `protobuf:"varint,8,opt,name=remote_address_family,json=remoteAddressFamily,enum=webrtc.rtclog.IceCandidatePairConfig_AddressFamily" json:"remote_address_family,omitempty"`
	// required
	CandidatePairProtocol *IceCandidatePairConfig_Protocol `protobuf:"varint,9,opt,name=candidate_pair_protocol,json=candidatePairProtocol,enum=webrtc.rtclog.IceCandidatePairConfig_Protocol" json:"candidate_pair_protocol,omitempty"`
	XXX_unrecognized      []byte                           `json:"-"`
}

func (m *IceCandidatePairConfig) Reset()                    { *m = IceCandidatePairConfig{} }
func (m *IceCandidatePairConfig) String() string            { return proto.CompactTextString(m) }
func (*IceCandidatePairConfig) ProtoMessage()               {}
func (*IceCandidatePairConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *IceCandidatePairConfig) GetConfigType() IceCandidatePairConfig_IceCandidatePairConfigType {
	if m != nil && m.ConfigType != nil {
		return *m.ConfigType
	}
	return IceCandidatePairConfig_ADDED
}

func (m *IceCandidatePairConfig) GetCandidatePairId() uint32 {
	if m != nil && m.CandidatePairId != nil {
		return *m.CandidatePairId
	}
	return 0
}

func (m *IceCandidatePairConfig) GetLocalCandidateType() IceCandidatePairConfig_IceCandidateType {
	if m != nil && m.LocalCandidateType != nil {
		return *m.LocalCandidateType
	}
	return IceCandidatePairConfig_LOCAL
}

func (m *IceCandidatePairConfig) GetLocalRelayProtocol() IceCandidatePairConfig_Protocol {
	if m != nil && m.LocalRelayProtocol != nil {
		return *m.LocalRelayProtocol
	}
	return IceCandidatePairConfig_UDP
}

func (m *IceCandidatePairConfig) GetLocalNetworkType() IceCandidatePairConfig_NetworkType {
	if m != nil && m.LocalNetworkType != nil {
		return *m.LocalNetworkType
	}
	return IceCandidatePairConfig_ETHERNET
}

func (m *IceCandidatePairConfig) GetLocalAddressFamily() IceCandidatePairConfig_AddressFamily {
	if m != nil && m.LocalAddressFamily != nil {
		return *m.LocalAddressFamily
	}
	return IceCandidatePairConfig_IPV4
}

func (m *IceCandidatePairConfig) GetRemoteCandidateType() IceCandidatePairConfig_IceCandidateType {
	if m != nil && m.RemoteCandidateType != nil {
		return *m.RemoteCandidateType
	}
	return IceCandidatePairConfig_LOCAL
}

func (m *IceCandidatePairConfig) GetRemoteAddressFamily() IceCandidatePairConfig_AddressFamily {
	if m != nil && m.RemoteAddressFamily != nil {
		return *m.RemoteAddressFamily
	}
	return IceCandidatePairConfig_IPV4
}

func (m *IceCandidatePairConfig) GetCandidatePairProtocol() IceCandidatePairConfig_Protocol {
	if m != nil && m.CandidatePairProtocol != nil {
		return *m.CandidatePairProtocol
	}
	return IceCandidatePairConfig_UDP
}

type IceCandidatePairEvent struct {
	// required
	EventType *IceCandidatePairEvent_IceCandidatePairEventType `protobuf:"varint,1,opt,name=event_type,json=eventType,enum=webrtc.rtclog.IceCandidatePairEvent_IceCandidatePairEventType" json:"event_type,omitempty"`
	// required
	CandidatePairId  *uint32 `protobuf:"varint,2,opt,name=candidate_pair_id,json=candidatePairId" json:"candidate_pair_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *IceCandidatePairEvent) Reset()                    { *m = IceCandidatePairEvent{} }
func (m *IceCandidatePairEvent) String() string            { return proto.CompactTextString(m) }
func (*IceCandidatePairEvent) ProtoMessage()               {}
func (*IceCandidatePairEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *IceCandidatePairEvent) GetEventType() IceCandidatePairEvent_IceCandidatePairEventType {
	if m != nil && m.EventType != nil {
		return *m.EventType
	}
	return IceCandidatePairEvent_CHECK_SENT
}

func (m *IceCandidatePairEvent) GetCandidatePairId() uint32 {
	if m != nil && m.CandidatePairId != nil {
		return *m.CandidatePairId
	}
	return 0
}

func init() {
	proto.RegisterType((*EventStream)(nil), "webrtc.rtclog.EventStream")
	proto.RegisterType((*Event)(nil), "webrtc.rtclog.Event")
	proto.RegisterType((*RtpPacket)(nil), "webrtc.rtclog.RtpPacket")
	proto.RegisterType((*RtcpPacket)(nil), "webrtc.rtclog.RtcpPacket")
	proto.RegisterType((*AudioPlayoutEvent)(nil), "webrtc.rtclog.AudioPlayoutEvent")
	proto.RegisterType((*LossBasedBweUpdate)(nil), "webrtc.rtclog.LossBasedBweUpdate")
	proto.RegisterType((*DelayBasedBweUpdate)(nil), "webrtc.rtclog.DelayBasedBweUpdate")
	proto.RegisterType((*VideoReceiveConfig)(nil), "webrtc.rtclog.VideoReceiveConfig")
	proto.RegisterType((*DecoderConfig)(nil), "webrtc.rtclog.DecoderConfig")
	proto.RegisterType((*RtpHeaderExtension)(nil), "webrtc.rtclog.RtpHeaderExtension")
	proto.RegisterType((*RtxConfig)(nil), "webrtc.rtclog.RtxConfig")
	proto.RegisterType((*RtxMap)(nil), "webrtc.rtclog.RtxMap")
	proto.RegisterType((*VideoSendConfig)(nil), "webrtc.rtclog.VideoSendConfig")
	proto.RegisterType((*EncoderConfig)(nil), "webrtc.rtclog.EncoderConfig")
	proto.RegisterType((*AudioReceiveConfig)(nil), "webrtc.rtclog.AudioReceiveConfig")
	proto.RegisterType((*AudioSendConfig)(nil), "webrtc.rtclog.AudioSendConfig")
	proto.RegisterType((*AudioNetworkAdaptation)(nil), "webrtc.rtclog.AudioNetworkAdaptation")
	proto.RegisterType((*BweProbeCluster)(nil), "webrtc.rtclog.BweProbeCluster")
	proto.RegisterType((*BweProbeResult)(nil), "webrtc.rtclog.BweProbeResult")
	proto.RegisterType((*AlrState)(nil), "webrtc.rtclog.AlrState")
	proto.RegisterType((*IceCandidatePairConfig)(nil), "webrtc.rtclog.IceCandidatePairConfig")
	proto.RegisterType((*IceCandidatePairEvent)(nil), "webrtc.rtclog.IceCandidatePairEvent")
	proto.RegisterEnum("webrtc.rtclog.MediaType", MediaType_name, MediaType_value)
	proto.RegisterEnum("webrtc.rtclog.Event_EventType", Event_EventType_name, Event_EventType_value)
	proto.RegisterEnum("webrtc.rtclog.DelayBasedBweUpdate_DetectorState", DelayBasedBweUpdate_DetectorState_name, DelayBasedBweUpdate_DetectorState_value)
	proto.RegisterEnum("webrtc.rtclog.VideoReceiveConfig_RtcpMode", VideoReceiveConfig_RtcpMode_name, VideoReceiveConfig_RtcpMode_value)
	proto.RegisterEnum("webrtc.rtclog.BweProbeResult_ResultType", BweProbeResult_ResultType_name, BweProbeResult_ResultType_value)
	proto.RegisterEnum("webrtc.rtclog.IceCandidatePairConfig_IceCandidatePairConfigType", IceCandidatePairConfig_IceCandidatePairConfigType_name, IceCandidatePairConfig_IceCandidatePairConfigType_value)
	proto.RegisterEnum("webrtc.rtclog.IceCandidatePairConfig_IceCandidateType", IceCandidatePairConfig_IceCandidateType_name, IceCandidatePairConfig_IceCandidateType_value)
	proto.RegisterEnum("webrtc.rtclog.IceCandidatePairConfig_Protocol", IceCandidatePairConfig_Protocol_name, IceCandidatePairConfig_Protocol_value)
	proto.RegisterEnum("webrtc.rtclog.IceCandidatePairConfig_AddressFamily", IceCandidatePairConfig_AddressFamily_name, IceCandidatePairConfig_AddressFamily_value)
	proto.RegisterEnum("webrtc.rtclog.IceCandidatePairConfig_NetworkType", IceCandidatePairConfig_NetworkType_name, IceCandidatePairConfig_NetworkType_value)
	proto.RegisterEnum("webrtc.rtclog.IceCandidatePairEvent_IceCandidatePairEventType", IceCandidatePairEvent_IceCandidatePairEventType_name, IceCandidatePairEvent_IceCandidatePairEventType_value)
}

func init() { proto.RegisterFile("rtc_event_log.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2329 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x6e, 0xdb, 0xc8,
	0x15, 0x16, 0x25, 0xcb, 0x96, 0x8e, 0x2c, 0x99, 0x1e, 0x5b, 0x8e, 0x9c, 0x6c, 0xfe, 0xb8, 0x6d,
	0x61, 0x04, 0x85, 0x91, 0x7a, 0x17, 0xc1, 0x16, 0xfd, 0x5b, 0x4a, 0xa4, 0x63, 0x22, 0xb4, 0xc8,
	0x0e, 0x29, 0xbb, 0x2e, 0xb0, 0x60, 0x69, 0x72, 0xe2, 0xb0, 0x91, 0x48, 0x81, 0xa4, 0x12, 0x1b,
	0xbd, 0x68, 0xfb, 0x00, 0xbd, 0x2d, 0xd0, 0xbb, 0x5e, 0xf4, 0x41, 0xfa, 0x16, 0xbd, 0xed, 0x13,
	0xf4, 0xb2, 0xd7, 0xc5, 0xcc, 0x90, 0xb4, 0x7e, 0x98, 0x3a, 0x9b, 0xdd, 0x1b, 0x89, 0x73, 0xe6,
	0xcc, 0x37, 0xe7, 0x9c, 0x39, 0x73, 0x7e, 0x06, 0x76, 0xe2, 0xd4, 0x73, 0xc8, 0x3b, 0x12, 0xa6,
	0xce, 0x38, 0xba, 0x3a, 0x9c, 0xc6, 0x51, 0x1a, 0xa1, 0xf6, 0x7b, 0x72, 0x19, 0xa7, 0xde, 0x61,
	0x9c, 0x7a, 0xe3, 0xe8, 0x4a, 0xfa, 0x19, 0xb4, 0x54, 0xca, 0x61, 0xa5, 0x31, 0x71, 0x27, 0xe8,
	0xc7, 0xb0, 0x9e, 0xb0, 0xaf, 0x9e, 0xf0, 0xa4, 0x76, 0xd0, 0x3a, 0xda, 0x3d, 0x5c, 0x60, 0x3f,
	0x64, 0xbc, 0x38, 0xe3, 0x91, 0xfe, 0xd2, 0x81, 0x3a, 0xa3, 0xa0, 0xa7, 0xb0, 0x99, 0x06, 0x13,
	0x92, 0xa4, 0xee, 0x64, 0xea, 0xcc, 0x92, 0x9e, 0xf0, 0x44, 0x38, 0xa8, 0xe1, 0x56, 0x41, 0x1b,
	0x25, 0xe8, 0x08, 0xd6, 0xd2, 0x9b, 0x29, 0xe9, 0x55, 0x9f, 0x08, 0x07, 0x9d, 0xa3, 0x47, 0x65,
	0xc0, 0xfc, 0xd7, 0xbe, 0x99, 0x12, 0xcc, 0x78, 0xd1, 0x4f, 0x01, 0xe2, 0x74, 0xea, 0x4c, 0x5d,
	0xef, 0x2d, 0x49, 0x7b, 0xb5, 0x27, 0xc2, 0x41, 0xeb, 0xa8, 0xb7, 0xb4, 0x12, 0xa7, 0x53, 0x93,
	0xcd, 0x9f, 0x54, 0x70, 0x33, 0xce, 0x07, 0xe8, 0xe7, 0xd0, 0x8a, 0x53, 0xaf, 0x58, 0xbb, 0xc6,
	0xd6, 0xee, 0xaf, 0xac, 0xf5, 0x6e, 0x17, 0x43, 0x5c, 0x8c, 0x10, 0x86, 0x1d, 0x77, 0xe6, 0x07,
	0x91, 0x33, 0x1d, 0xbb, 0x37, 0xd1, 0x2c, 0xe5, 0x66, 0xec, 0xd5, 0x19, 0xca, 0x93, 0x25, 0x14,
	0x99, 0x72, 0x9a, 0x9c, 0x91, 0x69, 0x70, 0x52, 0xc1, 0xdb, 0xee, 0x32, 0x11, 0x9d, 0x41, 0x77,
	0x1c, 0x25, 0x89, 0x73, 0xe9, 0x26, 0xc4, 0x77, 0x2e, 0xdf, 0x13, 0x67, 0x36, 0xf5, 0xdd, 0x94,
	0xf4, 0xd6, 0x19, 0xea, 0xd3, 0x25, 0x54, 0x3d, 0x4a, 0x92, 0x3e, 0x65, 0xed, 0xbf, 0x27, 0x23,
	0xc6, 0x78, 0x52, 0xc1, 0x68, 0xbc, 0x42, 0x45, 0x17, 0xb0, 0xe7, 0x93, 0xb1, 0x7b, 0xb3, 0x0a,
	0xbc, 0xc1, 0x80, 0xa5, 0x25, 0x60, 0x85, 0x32, 0xaf, 0x20, 0xef, 0xf8, 0xab, 0x64, 0x74, 0x0e,
	0xdd, 0x77, 0x81, 0x4f, 0x22, 0x27, 0x26, 0x1e, 0x09, 0xde, 0x91, 0xd8, 0xf1, 0xa2, 0xf0, 0x75,
	0x70, 0xd5, 0x6b, 0x94, 0x8a, 0x7c, 0x46, 0x79, 0x31, 0x67, 0x1d, 0x30, 0x46, 0x0a, 0xfc, 0x6e,
	0x8e, 0x1a, 0x73, 0x32, 0x32, 0x81, 0x93, 0x9d, 0x84, 0x84, 0xfe, 0x2d, 0x6c, 0x93, 0xc1, 0x3e,
	0x2a, 0x83, 0xb5, 0x48, 0xe8, 0x17, 0x98, 0xdb, 0xef, 0x72, 0x52, 0x81, 0x78, 0x0e, 0x5d, 0x7e,
	0x62, 0xcb, 0xa2, 0x42, 0xa9, 0xa8, 0xec, 0xcc, 0x56, 0x44, 0x75, 0xe7, 0xa8, 0x73, 0xa2, 0x72,
	0xe0, 0x45, 0x51, 0x5b, 0xa5, 0xa2, 0x32, 0xd8, 0x45, 0x51, 0xdd, 0x9c, 0x54, 0x20, 0xba, 0xd0,
	0xe3, 0x88, 0x21, 0x49, 0xdf, 0x47, 0xf1, 0x5b, 0xc7, 0xf5, 0xdd, 0x69, 0xea, 0xa6, 0x41, 0x14,
	0xf6, 0x44, 0x06, 0xfb, 0xc3, 0x32, 0xd8, 0x21, 0xe7, 0x96, 0x0b, 0xe6, 0x93, 0x0a, 0xde, 0x73,
	0x4b, 0x67, 0x90, 0x0a, 0xed, 0x69, 0x1c, 0x5d, 0x12, 0xc7, 0x1b, 0xcf, 0x92, 0x94, 0xc4, 0xbd,
	0xed, 0x52, 0x71, 0xfb, 0xef, 0x89, 0x49, 0xd9, 0x06, 0x9c, 0xeb, 0xa4, 0x82, 0x37, 0xa7, 0x73,
	0x63, 0xd4, 0x07, 0x3e, 0x76, 0x62, 0x92, 0xcc, 0xc6, 0x69, 0x0f, 0x31, 0x94, 0x87, 0x1f, 0x40,
	0xc1, 0x8c, 0xe9, 0xa4, 0x82, 0x5b, 0xd3, 0xdb, 0x21, 0x7a, 0x01, 0x4d, 0x77, 0x1c, 0x3b, 0x49,
	0x4a, 0x3d, 0x72, 0x87, 0x01, 0xdc, 0x5b, 0x56, 0x6f, 0x1c, 0x5b, 0x29, 0x77, 0xc3, 0x86, 0x9b,
	0x7d, 0xa3, 0x4b, 0xd8, 0x0f, 0x3c, 0xe2, 0x78, 0x6e, 0xe8, 0x07, 0xd4, 0x19, 0x9d, 0xa9, 0x1b,
	0x14, 0xd6, 0xdf, 0x2d, 0x35, 0x93, 0xe6, 0x91, 0x41, 0xce, 0x6e, 0xba, 0x41, 0x5c, 0x1c, 0xc2,
	0x5e, 0x50, 0x3a, 0x83, 0x1c, 0xe8, 0x95, 0xec, 0xc1, 0xef, 0x7a, 0x97, 0x6d, 0xf1, 0x83, 0x3b,
	0xb6, 0xc8, 0xef, 0x7b, 0x37, 0x28, 0x9b, 0x90, 0xfe, 0x5d, 0x83, 0x66, 0x11, 0xd4, 0xd0, 0x36,
	0xb4, 0x47, 0xc3, 0x57, 0x43, 0xe3, 0x7c, 0xe8, 0xa8, 0x67, 0xea, 0xd0, 0x16, 0x2b, 0xa8, 0x0d,
	0x4d, 0xdd, 0x78, 0xe9, 0x58, 0xb6, 0x8c, 0x6d, 0x51, 0x40, 0x2d, 0xd8, 0xa0, 0x43, 0x75, 0xa8,
	0x88, 0x55, 0x3a, 0x87, 0x6d, 0x33, 0x63, 0xad, 0xa1, 0x0e, 0x00, 0xb6, 0x07, 0xf9, 0x78, 0x0d,
	0xdd, 0x83, 0x1d, 0x79, 0xa4, 0x68, 0x86, 0x63, 0xea, 0xf2, 0x85, 0x31, 0xb2, 0xb3, 0x89, 0x3a,
	0xda, 0x87, 0xae, 0x6e, 0x58, 0x96, 0xd3, 0x97, 0x2d, 0x55, 0x71, 0xfa, 0xe7, 0xaa, 0x33, 0x32,
	0x15, 0xd9, 0x56, 0xc5, 0x75, 0x74, 0x1f, 0xf6, 0x14, 0x55, 0x97, 0x2f, 0x56, 0xe7, 0x36, 0xd0,
	0x63, 0x78, 0x70, 0xa6, 0x29, 0xaa, 0xe1, 0x60, 0x75, 0xa0, 0x6a, 0x67, 0x2a, 0x76, 0x06, 0xc6,
	0xf0, 0x58, 0x7b, 0x99, 0xe1, 0x36, 0xd0, 0x43, 0xd8, 0xe7, 0x0c, 0x96, 0x3a, 0x54, 0x96, 0xa7,
	0x9b, 0x74, 0x3d, 0x97, 0xa7, 0x7c, 0x3d, 0xd0, 0xf5, 0x9c, 0xa1, 0x6c, 0x7d, 0x0b, 0x49, 0xf0,
	0x88, 0x4f, 0x0f, 0x55, 0xfb, 0xdc, 0xc0, 0xaf, 0x1c, 0x59, 0x91, 0x4d, 0x5b, 0xb6, 0x35, 0x23,
	0x37, 0x97, 0x88, 0x3e, 0x87, 0xc7, 0x54, 0x66, 0x13, 0x1b, 0x7d, 0xd5, 0x19, 0xe8, 0x23, 0xcb,
	0xa6, 0x38, 0x58, 0x95, 0x6d, 0x55, 0xc9, 0x98, 0xb6, 0xa9, 0x92, 0xb7, 0x4c, 0x58, 0xb5, 0x46,
	0x7a, 0x6e, 0x1b, 0x84, 0x76, 0x60, 0x4b, 0xd6, 0x31, 0xb5, 0xb7, 0xad, 0x66, 0xc4, 0x1d, 0x2a,
	0x98, 0x36, 0x50, 0x9d, 0x81, 0x3c, 0x54, 0x34, 0x6a, 0x0c, 0xc7, 0x94, 0xb5, 0x5c, 0x3c, 0x71,
	0x17, 0x7d, 0x06, 0xbd, 0x92, 0x69, 0xbe, 0xb8, 0xdb, 0x6f, 0xc2, 0x46, 0x32, 0xbb, 0xa4, 0xe9,
	0x4a, 0xfa, 0xa7, 0x00, 0xcd, 0x22, 0x1d, 0xa1, 0xfb, 0xd0, 0x08, 0x42, 0x2f, 0x9a, 0x04, 0xe1,
	0x15, 0xcb, 0x87, 0x0d, 0x5c, 0x8c, 0xd1, 0xf3, 0x85, 0x64, 0xb8, 0x9c, 0xd2, 0x4e, 0x89, 0x1f,
	0xb8, 0xd4, 0x63, 0xfa, 0xd5, 0x9e, 0x90, 0xa5, 0xc2, 0xcf, 0xa1, 0xcd, 0x53, 0x99, 0x33, 0x26,
	0xe1, 0x55, 0xfa, 0x86, 0x65, 0xc3, 0x36, 0xde, 0xe4, 0x44, 0x9d, 0xd1, 0xd0, 0x1e, 0xac, 0xbf,
	0x21, 0xae, 0x4f, 0x62, 0x96, 0xef, 0x36, 0x71, 0x36, 0x42, 0x07, 0x20, 0x2e, 0x84, 0x03, 0x27,
	0xf0, 0x59, 0x2e, 0xab, 0xe3, 0xce, 0xfc, 0x7d, 0xd7, 0x7c, 0xe9, 0x0f, 0x00, 0xb7, 0x49, 0xf1,
	0x7b, 0x56, 0xe1, 0x31, 0xb4, 0x32, 0x15, 0x7c, 0x37, 0x75, 0x99, 0x02, 0x9b, 0x18, 0x38, 0x49,
	0x71, 0x53, 0x57, 0x3a, 0x82, 0xed, 0x95, 0x5c, 0x8a, 0x1e, 0x02, 0x8c, 0x23, 0xcf, 0x1d, 0x3b,
	0x49, 0x12, 0x7b, 0x6c, 0xb7, 0x36, 0x6e, 0x32, 0x8a, 0x95, 0xc4, 0x9e, 0xf4, 0x47, 0x40, 0xab,
	0x99, 0x92, 0x6e, 0x75, 0x19, 0xa4, 0x31, 0xbd, 0xd2, 0x97, 0x53, 0x5e, 0x8e, 0xd4, 0x31, 0x64,
	0xa4, 0xfe, 0x34, 0xa1, 0xe6, 0x7c, 0x1d, 0xbb, 0x1e, 0x0d, 0x96, 0x0e, 0xcd, 0xa9, 0x19, 0xf0,
	0x66, 0x4e, 0xa4, 0x98, 0x94, 0x29, 0x8d, 0x52, 0x77, 0x9c, 0x15, 0x11, 0x09, 0x13, 0xb9, 0x8e,
	0x37, 0x19, 0x91, 0x9b, 0x28, 0x91, 0xfe, 0x25, 0xc0, 0x4e, 0x49, 0x4a, 0xbd, 0x5b, 0x84, 0x73,
	0xe8, 0xf8, 0x24, 0x25, 0x5e, 0x1a, 0xe5, 0xd1, 0x91, 0x9b, 0xf2, 0xf9, 0xdd, 0xf9, 0xfa, 0x50,
	0xc9, 0x16, 0xb2, 0x50, 0x89, 0xdb, 0xfe, 0xfc, 0x50, 0x3a, 0x86, 0xf6, 0xc2, 0x3c, 0x8d, 0x1c,
	0xf4, 0x42, 0x0c, 0x0d, 0x7c, 0x2a, 0xeb, 0x62, 0x05, 0x21, 0xe8, 0xb0, 0x9b, 0x4f, 0x6f, 0xe1,
	0xc8, 0xd2, 0x86, 0x2f, 0x45, 0x81, 0xc6, 0x26, 0x4a, 0x33, 0xce, 0x72, 0x52, 0x55, 0xfa, 0x7b,
	0x0d, 0xd0, 0x6a, 0x4a, 0xa7, 0x8a, 0xc5, 0x64, 0x12, 0xa5, 0x84, 0x9f, 0x88, 0xc0, 0x0c, 0x07,
	0x9c, 0x44, 0x8f, 0xe4, 0x8e, 0x13, 0x43, 0x2f, 0xa1, 0xc9, 0x2a, 0xb3, 0x49, 0xe4, 0x13, 0x66,
	0xd1, 0xce, 0xd1, 0xb3, 0x3b, 0x0b, 0x09, 0x56, 0xaa, 0x9d, 0x46, 0x3e, 0xc1, 0x8d, 0x38, 0xfb,
	0x42, 0x08, 0xd6, 0x62, 0x32, 0xb9, 0x64, 0xbe, 0xde, 0xc0, 0xec, 0x1b, 0x1d, 0xc2, 0x46, 0x9c,
	0x5e, 0x3b, 0x13, 0x77, 0xda, 0xab, 0xb3, 0x0a, 0xb6, 0xbb, 0x52, 0xf2, 0x5d, 0x9f, 0xba, 0x53,
	0xbc, 0x1e, 0xb3, 0x7f, 0x34, 0x84, 0x6d, 0x7e, 0x47, 0x1c, 0x72, 0x9d, 0x92, 0x30, 0x09, 0xa2,
	0x30, 0xe9, 0xad, 0xb3, 0x95, 0x4f, 0x57, 0x0b, 0xcd, 0x13, 0xc6, 0xaa, 0xe6, 0x9c, 0x58, 0x7c,
	0xb3, 0x48, 0x48, 0xd0, 0x57, 0xd0, 0xf0, 0x89, 0x17, 0xf9, 0x24, 0x4e, 0x7a, 0x1b, 0x0c, 0xe6,
	0xb3, 0x95, 0xe3, 0x64, 0xd3, 0x5c, 0x2d, 0x5c, 0x70, 0x4b, 0x5f, 0x40, 0x23, 0xd7, 0x91, 0x1e,
	0x06, 0x0b, 0xf5, 0x03, 0xe3, 0xd4, 0x34, 0x46, 0x43, 0x45, 0x14, 0xd0, 0x2e, 0x88, 0x8c, 0x84,
	0x55, 0x65, 0x34, 0x50, 0x15, 0x4b, 0xfb, 0xad, 0x2a, 0x56, 0xf9, 0x51, 0xcf, 0xe1, 0x51, 0x9b,
	0x84, 0xee, 0x84, 0xb0, 0x53, 0x69, 0x62, 0xf6, 0x4d, 0x8b, 0xf3, 0xa9, 0x7b, 0x33, 0x8e, 0x5c,
	0xdf, 0x29, 0x6e, 0x6c, 0x1d, 0xb7, 0x32, 0x1a, 0xbd, 0xa4, 0xd2, 0x57, 0x80, 0x56, 0xd5, 0x2b,
	0x05, 0xeb, 0x40, 0x35, 0xf0, 0x33, 0x88, 0x6a, 0xe0, 0x4b, 0x26, 0x0d, 0x79, 0xd7, 0xd9, 0xee,
	0xfb, 0xd0, 0xa0, 0xd6, 0x9f, 0xf3, 0x0b, 0x7a, 0x1a, 0xec, 0xd4, 0x0f, 0x40, 0xa4, 0x53, 0x25,
	0x82, 0x74, 0xe2, 0xf4, 0xda, 0x9c, 0x93, 0xe5, 0x1b, 0x58, 0xe7, 0x87, 0xb4, 0x22, 0xb8, 0xb0,
	0x22, 0x38, 0x7a, 0x0e, 0xeb, 0x59, 0x49, 0x50, 0xfd, 0x40, 0x77, 0x90, 0xc9, 0x86, 0x33, 0x3e,
	0xe9, 0xbf, 0x02, 0x6c, 0x2d, 0x55, 0x94, 0x68, 0x17, 0xea, 0x54, 0xe6, 0x84, 0x75, 0x3d, 0x6d,
	0xcc, 0x07, 0xe5, 0xbe, 0x51, 0xfd, 0x74, 0xdf, 0x78, 0x40, 0x1d, 0x9f, 0x5b, 0x87, 0x86, 0x12,
	0xba, 0x53, 0x23, 0x33, 0x4f, 0x52, 0x6a, 0x9f, 0xb5, 0x32, 0xfb, 0xa0, 0x17, 0xb0, 0x41, 0x42,
	0x76, 0xe6, 0x59, 0x3f, 0xb2, 0xec, 0x61, 0x6a, 0x38, 0xef, 0x61, 0x39, 0x33, 0xf5, 0x95, 0x85,
	0x99, 0x4f, 0xf5, 0x95, 0x7f, 0x08, 0x80, 0x56, 0xcb, 0xe7, 0xef, 0x1c, 0x16, 0x4a, 0xad, 0x5d,
	0xfb, 0x64, 0x6b, 0x4b, 0x33, 0xd8, 0x5a, 0xaa, 0xc6, 0xa9, 0xc2, 0x73, 0xb2, 0xb1, 0xef, 0xef,
	0xfb, 0x90, 0xa5, 0x3f, 0x57, 0x61, 0xaf, 0xbc, 0x5c, 0xbf, 0x3b, 0x23, 0xfc, 0x08, 0xb6, 0x5e,
	0xc7, 0xee, 0x84, 0x64, 0x29, 0xde, 0x99, 0x24, 0x99, 0xfd, 0xdb, 0x8c, 0xcc, 0x93, 0xfc, 0x69,
	0x82, 0x7e, 0x01, 0x0f, 0x66, 0xd3, 0x71, 0x10, 0xbe, 0x75, 0xf2, 0x92, 0x80, 0xf6, 0x95, 0x79,
	0xea, 0x62, 0x31, 0xb5, 0x8a, 0x7b, 0x9c, 0x85, 0xa7, 0x29, 0x9a, 0xce, 0x8e, 0xb3, 0x79, 0x7a,
	0x10, 0x24, 0x74, 0x2f, 0xc7, 0xc4, 0x79, 0x4d, 0xbc, 0x2c, 0x7a, 0x36, 0x39, 0xe5, 0x98, 0x78,
	0x73, 0xd3, 0x7e, 0x7a, 0xcd, 0x5c, 0xac, 0x98, 0x56, 0xd2, 0x6b, 0xea, 0x21, 0xe1, 0x6c, 0xe2,
	0x78, 0x6f, 0xdc, 0x30, 0x24, 0xe3, 0x84, 0x75, 0xaf, 0x6d, 0xdc, 0x0a, 0x67, 0x93, 0x41, 0x46,
	0x92, 0xfe, 0x24, 0xc0, 0xd6, 0x52, 0x6b, 0x91, 0xc5, 0x0d, 0x21, 0x8f, 0x1b, 0xcb, 0xc6, 0xa8,
	0xae, 0x18, 0xe3, 0x31, 0xb4, 0x26, 0x41, 0xb8, 0x90, 0x7a, 0xdb, 0x18, 0x26, 0x41, 0x98, 0x25,
	0x5e, 0x7a, 0x9d, 0x28, 0xc3, 0xe5, 0x4d, 0x4a, 0x12, 0xa6, 0x45, 0x1b, 0x37, 0x26, 0x41, 0xd8,
	0xa7, 0x63, 0xe9, 0x3f, 0x02, 0x74, 0x16, 0xfb, 0x92, 0x15, 0x09, 0xbe, 0x86, 0xf5, 0xac, 0xad,
	0xe1, 0x79, 0xf7, 0xe0, 0xff, 0xb6, 0x35, 0x87, 0xfc, 0x8f, 0x3d, 0x4e, 0x64, 0xeb, 0x96, 0x75,
	0xa8, 0x2d, 0xeb, 0x20, 0x05, 0x00, 0xb7, 0xcb, 0x68, 0x71, 0x6f, 0x8d, 0x06, 0x03, 0xd5, 0xb2,
	0xc4, 0x0a, 0x7a, 0x0a, 0x0f, 0xb5, 0xe1, 0x99, 0xac, 0x6b, 0x0a, 0x2b, 0x87, 0xf3, 0xa2, 0xd9,
	0xd1, 0x86, 0xb6, 0x8a, 0xcf, 0x64, 0x5d, 0x14, 0xd0, 0x23, 0xb8, 0x5f, 0xca, 0x82, 0x69, 0x4d,
	0x2c, 0x56, 0x29, 0x9e, 0xad, 0x9d, 0xaa, 0xc6, 0xc8, 0x16, 0x6b, 0xd2, 0x53, 0x68, 0xe4, 0x6d,
	0x14, 0xea, 0xc2, 0x7a, 0x10, 0x3a, 0xee, 0x38, 0xce, 0x8a, 0xb6, 0x7a, 0x10, 0xca, 0xe3, 0x58,
	0xfa, 0x2b, 0xc0, 0x5e, 0x79, 0x8b, 0x84, 0x5c, 0x68, 0xf1, 0xf0, 0x78, 0x1b, 0x68, 0x3b, 0x47,
	0x5f, 0x7f, 0x54, 0x7b, 0xf5, 0x01, 0x32, 0x33, 0x14, 0x78, 0xc5, 0x37, 0x7a, 0x06, 0xdb, 0x4b,
	0x7d, 0x56, 0x96, 0x47, 0xda, 0x78, 0xcb, 0x9b, 0x5f, 0xaf, 0xf9, 0xe8, 0x0d, 0xec, 0xf2, 0x50,
	0x71, 0xbb, 0x82, 0xc9, 0xc5, 0xab, 0x85, 0x17, 0xdf, 0x5e, 0x2e, 0x26, 0x0d, 0x62, 0x98, 0x0b,
	0x34, 0xf4, 0xbb, 0x7c, 0xa7, 0x98, 0x3d, 0xa1, 0xb0, 0x37, 0x32, 0x2f, 0x1a, 0x33, 0x7f, 0xea,
	0x1c, 0x1d, 0x7e, 0xdc, 0x4e, 0x66, 0xb6, 0x2a, 0xdb, 0x01, 0x53, 0xa8, 0x9c, 0x86, 0x1c, 0xe0,
	0xd4, 0xa2, 0xdb, 0x67, 0x9a, 0xd4, 0x19, 0xfe, 0x4f, 0x3e, 0x0e, 0x3f, 0x0b, 0x25, 0x4c, 0x09,
	0x91, 0x81, 0xcd, 0x51, 0x10, 0xc9, 0x55, 0x70, 0x7d, 0x3f, 0x26, 0x34, 0x10, 0xb8, 0x93, 0x60,
	0x7c, 0xc3, 0x2e, 0x66, 0xe7, 0xe8, 0x8b, 0x8f, 0xdb, 0x42, 0xe6, 0x6b, 0x8f, 0xd9, 0xd2, 0x4c,
	0x8f, 0x05, 0x1a, 0xfa, 0x3d, 0x74, 0xb3, 0xf8, 0xbe, 0x74, 0x28, 0x1b, 0xdf, 0xe9, 0x50, 0x76,
	0x38, 0xe8, 0xe2, 0xa9, 0x5c, 0x15, 0x7b, 0x2d, 0xe9, 0xd4, 0xf8, 0x74, 0x9d, 0xb2, 0x8d, 0x16,
	0x95, 0x7a, 0x0d, 0xf7, 0x96, 0x9c, 0xb2, 0xf0, 0x80, 0xe6, 0x27, 0x79, 0x40, 0x77, 0xc1, 0x95,
	0x73, 0xb2, 0xf4, 0x6b, 0xb8, 0xff, 0xe1, 0x6b, 0x82, 0x9a, 0x50, 0x97, 0x15, 0x45, 0x55, 0xc4,
	0x0a, 0xbd, 0xd3, 0xbc, 0x21, 0xa7, 0x35, 0x5f, 0x1b, 0x9a, 0x8a, 0x6a, 0xd9, 0xd8, 0xb8, 0x50,
	0x15, 0xb1, 0x8a, 0x36, 0xa1, 0x61, 0xa9, 0xba, 0x3a, 0xa0, 0x93, 0x35, 0xe9, 0x02, 0xc4, 0x65,
	0x63, 0x52, 0x20, 0xdd, 0x18, 0xb0, 0x1a, 0xbf, 0x01, 0x6b, 0x96, 0x3d, 0x1a, 0x8a, 0x02, 0x25,
	0x9a, 0xf8, 0x58, 0xff, 0x8d, 0x58, 0xa5, 0x9f, 0x98, 0xb6, 0xff, 0x62, 0x8d, 0x36, 0xc9, 0xf9,
	0x5b, 0xc4, 0x6d, 0x63, 0x6b, 0x5f, 0x98, 0xaa, 0xb8, 0x26, 0xbd, 0x84, 0x46, 0xe1, 0xbe, 0x1b,
	0x50, 0x1b, 0x29, 0xa6, 0x58, 0xa1, 0x1f, 0xf6, 0xc0, 0x14, 0x05, 0x04, 0xb0, 0x6e, 0x59, 0x3a,
	0xfd, 0xae, 0x32, 0xa2, 0x6e, 0x89, 0x35, 0x5a, 0x9e, 0xe6, 0x70, 0x26, 0x36, 0x6c, 0x63, 0x60,
	0xe8, 0xe2, 0x9a, 0xf4, 0x2b, 0x68, 0x2f, 0xda, 0xbb, 0x01, 0x6b, 0x9a, 0x79, 0xf6, 0x25, 0x97,
	0x4f, 0x33, 0xcf, 0x5e, 0x88, 0xc2, 0xbc, 0x24, 0xb2, 0xa2, 0x60, 0xd5, 0xb2, 0x9c, 0x63, 0xf9,
	0x54, 0xd3, 0x2f, 0xc4, 0xaa, 0xe4, 0x43, 0x6b, 0xde, 0xd5, 0x37, 0xa1, 0xa1, 0xda, 0x27, 0x2a,
	0x1e, 0xaa, 0xb6, 0x58, 0xa1, 0x23, 0xdd, 0x30, 0xcc, 0xbe, 0x3c, 0x78, 0x25, 0x0a, 0x14, 0xf0,
	0x5c, 0x3b, 0xd6, 0xb8, 0x50, 0x67, 0xe6, 0x50, 0xac, 0x51, 0x86, 0x81, 0xaa, 0xeb, 0x23, 0x5d,
	0xc6, 0xe2, 0x1a, 0xea, 0xc1, 0x6e, 0xbe, 0x4f, 0xfe, 0xc2, 0xc0, 0xf4, 0xad, 0x4b, 0x7f, 0xab,
	0x42, 0xb7, 0xf4, 0x61, 0x07, 0x7d, 0x03, 0xc0, 0x1f, 0xd0, 0xe7, 0xc2, 0xe2, 0x2f, 0x3f, 0xe6,
	0x49, 0xa8, 0x9c, 0xca, 0x3c, 0xbe, 0x49, 0x8a, 0x07, 0xa1, 0x6f, 0x11, 0x13, 0xa5, 0x19, 0xec,
	0x7f, 0x10, 0x93, 0x76, 0x78, 0x83, 0x13, 0x75, 0xf0, 0x8a, 0x26, 0x0a, 0x9b, 0x77, 0x78, 0x7c,
	0x9c, 0xe5, 0x0c, 0xea, 0x4d, 0xf7, 0x60, 0x27, 0xa7, 0x59, 0xa6, 0x31, 0xb4, 0x54, 0xce, 0x5c,
	0x45, 0x0f, 0xe0, 0xde, 0xd2, 0x44, 0xb1, 0xaa, 0xf6, 0xec, 0x4b, 0x68, 0x16, 0xbd, 0x3c, 0xb5,
	0xac, 0x3c, 0xbc, 0x10, 0x2b, 0xcc, 0x63, 0x47, 0x8a, 0x66, 0x70, 0xf7, 0x62, 0xaf, 0x42, 0x62,
	0x95, 0x1e, 0x81, 0x22, 0xdb, 0xb2, 0x58, 0xeb, 0x57, 0x4f, 0x6a, 0xff, 0x0b, 0x00, 0x00, 0xff,
	0xff, 0x87, 0xc5, 0xe3, 0x1f, 0x7f, 0x18, 0x00, 0x00,
}
